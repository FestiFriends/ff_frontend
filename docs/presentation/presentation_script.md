# Festi Friends 발표 대본

## 슬라이드 1: 팀 소개
안녕하세요. 3조 Festi Friends입니다.
저희는 프론트엔드 5명, 백엔드 2명, 디자이너 1명으로 구성된 팀으로,
공연 동행 매칭 플랫폼을 개발했습니다. 지금부터 저희가 약 한 달간 개발한 결과물을 보여드리겠습니다.

## 슬라이드 2: 프로젝트 개요
저희 서비스는 혼자 공연을 보기 부담스러운 사람들을 위한 동행 매칭 플랫폼입니다.
기존의 단순한 매칭이 아닌, 신뢰를 기반으로 한 안전한 동행을 목표로 삼았습니다.

## 슬라이드 3: 핵심 아이디어
공연 동행에는 중요한 딜레마가 있습니다. 경제적 이익과 안전성 사이의 균형이죠.
저희는 이 문제를 두 가지 방법으로 해결했습니다. 리뷰 시스템을 통한 신뢰도 확보와, 실시간 채팅을 통한 사전 소통입니다.

## 슬라이드 4: 팀 구성 - Frontend
프론트엔드 개발팀은 효율적인 작업을 위해 도메인별로 역할을 분담했습니다.
각자 맡은 영역에서 전문성을 발휘하면서도, 전체적인 일관성을 유지하는 데 집중했습니다.

## 슬라이드 5: 팀 구성 - Backend & Design
백엔드 팀은 안정적인 API 서버 구축을, 디자이너는 일관된 UI/UX 설계를 담당했습니다.
이제 저희가 왜 이런 기술들을 선택했는지, 기술 스택에 대해 말씀드리겠습니다.

## 슬라이드 6: 기술 스택
저희는 현대적이고 확장 가능한 아키텍처를 위해 최신 기술 스택을 선택했습니다.
특히 Next.js 15와 React 19를 기반으로, TypeScript의 강력한 타입 안전성을 확보하는 데 중점을 두었습니다.

## 슬라이드 7: Frontend Core
핵심 기술부터 살펴보면, Next.js 15의 App Router와 Server Components로 성능을 최적화했고,
React 19의 최신 기능들을 적극 활용했습니다.
그리고 TailwindCSS로 일관되고 유지보수하기 쉬운 스타일링 시스템을 구축했습니다.

## 슬라이드 8: 상태 관리 & 데이터
상태 관리는 명확한 분리 원칙을 적용했습니다. Zustand로 클라이언트 상태를, TanStack Query로 서버 상태를 각각 관리해서,
복잡성을 줄이면서도 효율적인 데이터 플로우와 캐싱 최적화를 달성할 수 있었습니다.

## 슬라이드 9: 개발 도구 & 품질 관리
코드 품질 확보를 위해서는 테스트 커버리지 70% 이상을 달성했고,
MSW를 활용해 백엔드와 완전히 독립적인 개발 환경을 구축했습니다.
또한 ESLint, Prettier, Husky로 코드 품질을 자동화해서 일관성을 유지했습니다.
다음으로는 이런 기술들을 어떻게 구조화했는지 보겠습니다.

## 슬라이드 10: 프로젝트 아키텍처
저희는 확장성과 유지보수성을 고려한 모듈러 아키텍처를 설계했습니다.
특히 5명의 개발자가 동시에 작업할 때 충돌을 최소화하면서, 각자의 역할을 명확히 할 수 있는 구조에 집중했습니다.

## 슬라이드 11: 폴더 구조
보시는 것처럼 각 폴더의 역할이 명확하게 분리되어 있습니다.
이런 구조 덕분에 개발자가 원하는 코드를 쉽게 찾을 수 있고, 실제로 5명이 동시에 작업해도 거의 충돌이 발생하지 않았습니다.

## 슬라이드 12: 컴포넌트 계층 구조
컴포넌트는 재사용성을 기준으로 계층적으로 구조화했습니다.
가장 범용적인 공통 컴포넌트부터 시작해서, 페이지에 특화된 컴포넌트까지 체계적으로 관리했습니다.
이제 실제 개발 과정에서 적용한 방법론들을 보겠습니다.

## 슬라이드 13: 개발 방법론
효율적인 개발을 위해 두 가지 핵심 방법론을 채택했습니다.
이 방법론들 덕분에 안정적이면서도 빠른 개발이 가능했는데, 먼저 컴포넌트 중심 개발부터 설명드리겠습니다.

## 슬라이드 14: Component Driven Development
상향식 개발 방식으로, 가장 작은 단위인 재사용 가능한 컴포넌트부터 구축했습니다.
공통 컴포넌트를 먼저 완성하고 충분히 테스트한 후, 이를 조합해서 페이지를 만드는 방식이었습니다.
덕분에 안정성과 UI 일관성을 동시에 확보할 수 있었습니다.

## 슬라이드 15: API First Development
두 번째는 API First Development입니다.
TypeScript 인터페이스를 먼저 정의하고 MSW로 실제와 똑같이 모킹해서,
백엔드 개발을 기다리지 않고 완전히 병렬로 작업할 수 있었습니다.
이제 팀 협업을 위한 형상 관리 전략을 보겠습니다.

## 슬라이드 16: 형상 관리 전략
체계적인 협업을 위해 3단계 브랜치 전략을 구축했습니다.
무엇보다 안전한 코드 통합과 충돌 최소화에 중점을 두었습니다.

## 슬라이드 17: 브랜치 전략
develop은 안정적인 메인 브랜치, base는 기능별 통합 공간, sub-base는 개별 작업 공간으로 운영했습니다.
이런 구조로 개발자들이 서로 방해받지 않으면서도, 안정적으로 코드를 통합할 수 있었습니다.

## 슬라이드 18: 코드 리뷰 프로세스
모든 PR은 팀원 전체가 리뷰하는 전원 승인 원칙을 적용했습니다.
처음엔 시간이 오래 걸릴 것 같았지만, 오히려 코드 품질 향상과 함께 팀 전체의 기술 수준을 함께 높일 수 있는 좋은 기회였습니다.
이제 실제 구현한 핵심 기능들을 보겠습니다.

## 슬라이드 19: 주요 기능 구현
사용자가 실제로 서비스를 이용하는 전체 플로우를 고려해서,
공연 검색부터 시작해서 동행 매칭, 신뢰도 확인까지 완전한 서비스 경험을 설계했습니다.

## 슬라이드 20: 공연 목록 & 검색
사용자가 원하는 공연을 빠르고 쉽게 찾을 수 있도록
무한 스크롤, 다중 필터링, 실시간 검색 기능을 모두 구현했습니다.
특히 Intersection Observer를 활용해서 스크롤 성능을 크게 최적화했습니다.

## 슬라이드 21: 그룹 매칭 시스템
단순한 매칭이 아닌, 정말 맞는 사람을 찾을 수 있도록 세밀한 필터링 시스템을 만들었습니다.
그리고 WebSocket 기반 실시간 채팅으로 미리 충분히 소통할 수 있게 했고,
그룹별 공유 캘린더로 약속 관리까지 지원합니다.

## 슬라이드 22: 신뢰도 시스템
서비스의 핵심인 신뢰도 시스템입니다.
동행이 끝난 후 서로를 평가하는 상호 리뷰 시스템을 만들었고, 시간 약속이나 친화력 같은 세분화된 태그로 구체적인 평가가 가능합니다.
이제 이런 기능들을 구현하면서 해결한 기술적 도전들을 살펴보겠습니다.

## 슬라이드 23: 핵심 기술 구현
정말 품질 높은 웹 애플리케이션을 만들기 위해서는 여러 복잡한 기술적 문제들을 해결해야 했습니다.
가장 중요했던 상태 관리 아키텍처부터 차근차근 설명드리겠습니다.

## 슬라이드 24: 상태 관리 아키텍처
저희만의 3단계 상태 관리 전략을 설계했습니다.
URL 상태, 서버 상태, 클라이언트 상태를 명확히 분리해서 각각의 책임을 나누었는데, 이게 정말 개발 복잡성을 크게 줄여줬습니다.

## 슬라이드 25: URL 기반 상태 관리
URL을 단순한 주소가 아닌 상태 관리의 핵심 도구로 활용했습니다.
사용자가 검색하고 필터링한 결과를 URL로 그대로 공유할 수 있고, 새로고침해도 똑같은 상태가 유지되죠.

## 슬라이드 26: 쿼리 파라미터 관리 시스템
이런 URL 상태 관리를 위해 전용 커스텀 훅을 만들었습니다.
복잡한 쿼리 파라미터들을 효율적으로 관리하면서, Next.js 라우터와 완벽하게 연동되도록 구현했습니다.

## 슬라이드 27: 서버 상태 관리 - TanStack Query
여기서 흥미로운 점은, URL이 변경될 때마다 자동으로 새로운 캐시 키가 생성된다는 것입니다.
그래서 각 검색 조건별로 완전히 독립적인 캐싱이 이루어져서, 사용자 경험이 훨씬 좋아졌습니다.

## 슬라이드 28: 실제 구현 사례 - 공연 목록 페이지
실제 공연 목록 페이지에서 이 모든 개념들이 어떻게 통합되는지 보시면,
검색어, 필터, 정렬, 페이지네이션 모든 상태가 URL로 관리되어서 완전히 공유 가능하고 복원 가능한 검색 결과를 만들어냅니다.
이제 실시간 채팅 구현으로 넘어가보겠습니다.

## 슬라이드 29: 클라이언트 상태 관리 - Zustand
Zustand로는 정말 꼭 필요한 인증 상태만 관리해서 전체 상태 관리의 복잡성을 최소화했습니다.
대부분의 상태는 URL과 서버 상태로 충분히 처리할 수 있었거든요.

## 슬라이드 30: 실시간 채팅 시스템
실시간 채팅 구현에서는 정말 까다로운 문제들이 많았습니다.
토큰이 만료되었을 때의 자동 재인증, 사용자가 여러 그룹에 동시 참여하는 상황 관리, 그리고 HTTP API와 WebSocket을 자연스럽게 통합하는 것까지.

## 슬라이드 31: WebSocket 연결 관리 구현
STOMP와 SockJS를 조합해서 정말 안정적인 WebSocket 연결을 구현했습니다.
토큰 기반 인증부터 연결 상태 관리까지, 모든 복잡함을 하나의 커스텀 훅으로 추상화했습니다.

## 슬라이드 32: WebSocket 에러 처리 & 재연결
특히 토큰이 만료되었을 때 자동으로 새 토큰을 받아와서 재연결하는 로직을 구현했는데,
사용자는 연결이 끊어진 걸 전혀 느끼지 못할 정도로 매끄럽게 처리됩니다.

## 슬라이드 33: HTTP + WebSocket 데이터 통합
그리고 HTTP API로 받은 채팅 히스토리와 WebSocket으로 받는 실시간 메시지를 자연스럽게 병합해서,
정말 끊김 없는 하나의 연속된 채팅 경험을 만들어냈습니다.

## 슬라이드 34: 낙관적 업데이트
사용자가 버튼을 클릭했을 때 즉시 반응하는 UI를 위해 낙관적 업데이트도 구현했습니다.
서버 응답을 기다리지 않고 바로 UI를 업데이트해서, 정말 빠르고 반응성 좋은 경험을 제공합니다.

## 슬라이드 35: 반응형 디자인 구현
반응형 디자인에서는 단순히 화면 크기만 조정하는 게 아니라,
모바일과 데스크톱에서 완전히 다른 인터랙션 패턴을 구현해야 했습니다.

## 슬라이드 36: 디바이스별 UI 패턴 분기
각 디바이스에 정말 최적화된 경험을 제공하기 위해서,
모바일은 헤더와 하단 탭바, 데스크톱은 사이드 GNB로 완전히 다른 네비게이션 구조를 만들었습니다.

## 슬라이드 37: 터치 인터랙션 최적화
인터랙션도 디바이스 특성에 맞게 분기 처리했습니다.
모바일에서는 hover가 없으니까 클릭으로, 데스크톱에서는 hover로 각각 다르게 동작하도록 해서 정말 자연스러운 경험을 만들었습니다.

## 슬라이드 38: 드래그 스크롤 구현
특히 수평 스크롤이 필요한 부분에서는 터치 스크롤과 마우스 드래그를 모두 지원하는 범용 커스텀 훅을 만들어서,
어떤 디바이스에서든 편안한 스크롤 경험을 제공합니다.

## 슬라이드 39: 무한 스크롤 성능 최적화
성능 최적화 측면에서는, 기존의 스크롤 이벤트 방식 대신
Intersection Observer라는 브라우저 네이티브 API를 활용했습니다.

## 슬라이드 40: Intersection Observer 기반 무한 스크롤
이 방법으로 무한 스크롤을 구현하니까 성능이 정말 크게 향상되었습니다.
스크롤할 때마다 이벤트가 발생하는 게 아니라, 필요한 시점에만 트리거되거든요.

## 슬라이드 41: 범용 무한 스크롤 컴포넌트
그리고 이걸 재사용 가능한 범용 컴포넌트로 만들어서 다양한 목록에서 활용할 수 있게 했습니다.
Suspense와 ErrorBoundary까지 통합해서 정말 견고한 컴포넌트가 되었습니다.

## 슬라이드 42: 타입 안전성 확보
마지막으로 타입 안전성 확보입니다.
컴파일 타임의 TypeScript만으로는 부족해서, 런타임에서도 안전한 애플리케이션을 만들기 위해 Zod 스키마를 도입했습니다.

## 슬라이드 43: Zod 스키마 기반 폼 검증
Zod를 활용해서 복잡한 폼 검증 로직을 정말 선언적이고 읽기 쉽게 표현했습니다.
단순한 데이터 타입뿐만 아니라 복잡한 비즈니스 룰까지 스키마에 포함시켜서 완벽한 안전성을 확보했습니다.

## 슬라이드 44: 폼 컴포넌트 구현
React Hook Form과 Zod를 완벽하게 연동해서, 컴파일 타임과 런타임 모두에서 안전한 폼을 만들어냈습니다.
이제 이런 노력들의 결과인 프로젝트 성과를 보겠습니다.

## 슬라이드 45: 프로젝트 성과
한 달 동안의 개발 결과로, 정말 실제 서비스 수준의 완성도를 달성할 수 있었습니다.
구체적인 수치와 함께 성과를 보여드리겠습니다.

## 슬라이드 46: 개발 성과 지표
정량적으로 보면 총 500개 이상의 커밋, 80개 이상의 재사용 컴포넌트, 40개 이상의 커스텀 훅으로
정말 체계적이고 확장 가능한 코드베이스를 구축할 수 있었습니다.

## 슬라이드 47: 기능 구현 성과
기능적으로는 15개의 주요 페이지로 완전한 사용자 경험을 제공하고,
실시간 채팅부터 신뢰도 기반 매칭까지 복잡한 기능들을 모두 안정적으로 구현했습니다.

## 슬라이드 48: 품질 지표
품질 측면에서도 70% 이상의 테스트 커버리지와 Core Web Vitals 기준을 모두 충족해서,
안정성과 성능을 동시에 확보할 수 있었습니다.

## 슬라이드 49: 시연
이론적인 설명보다는 직접 보시는 게 좋을 것 같습니다.
지금부터 실제 개발한 서비스를 주요 사용자 플로우에 따라 시연해보겠습니다.

## 슬라이드 50: Q & A
이상으로 Festi Friends 프로젝트 발표를 마치겠습니다.
한 달간 정말 많은 것을 배우고 성장할 수 있었던 값진 경험이었습니다. 감사합니다.